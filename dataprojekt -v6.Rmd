---
title: "Projekt v6"
output: html_document
date: '2022-05-09'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(bigstatsr)
library(future.apply)
library(bigsnpr)
library(dplyr)
library(ggplot2)
library(tibble)
library(magrittr)
library(purrr)
```


```{r}
createRds <-  function(path, nrow, ncol) {
    G = FBM.code256(nrow = nrow, # number of rows
                     ncol = ncol, # number of columns
                     code = c(0L, 1L, 2L, rep(NA_integer_, 256 - 3)),
                     backingfile = path) 
    
    obj.bigsnp = list(
      genotypes = G,
      MAP = tibble(SNP_ID = 1:ncol),
      FAM = tibble(ID = 1:nrow))
      snp_save(obj.bigsnp)
  
  
  return(obj.bigsnp)
}

```


```{r}
verifyRds <- function(path, overwrite, nrow, ncol) {
  rds_file <- paste(path, ".rds", sep = "")
  if (file.exists(rds_file)) {
     if (overwrite) {
       FBM <- OpenRds(path)
       if (nrow(FBM$genotypes) != nrow | ncol(FBM$genotypes) != ncol) stop("An .rds file exists with same name but wrong dimensions. 
                                                           Cannot overwrite. Please choose another filename or change dimensions.")
     } else {
       stop("An .rds file of this name already exists. 
            Please allow overwrite or choose another filename.")
     }
   } else {
     FBM <- createRds(path, nrow, ncol)
   }
  return(FBM)
} 
  
 
```

```{r}
OpenRds <- function(path){
  rds_file <- paste(path, ".rds", sep = "")
  if (file.exists(rds_file)) {
  snp_attach(rds_file)  
  } else {
    stop("No file with that name.")
  }
} 
```


```{r}
sim_disease <- function(n_snp, prevalence, h2, causal = NULL, maf = NULL, maf_low = 0.01, maf_high = 0.49, seed = NULL){
  if (!is.null(seed)) {set.seed(seed)}
  
  #Calculates a vector with causal SNPs at random positions if a causal vector not given
  if (is.null(causal)) {
    causal <- numeric(n_snp)
    causal[sample(1:n_snp, max(1, round(n_snp / 10)))] <- 1
  }
  
  #Calculates MAF if not given
  if (is.null(maf))  {
    maf <- runif(n_snp, maf_low, maf_high)
    
  }
  #Calcualtes betas for causal SNPs
  c <- sum(causal)
  beta <- ifelse(causal == 1, rnorm(n_snp, 0, sqrt(h2 / c)), 0)
  
  return(list(MAF = maf, BETA = beta, CAUSAL = causal, H2 = h2, PREVALENCE = prevalence, N_SNP = n_snp))
}

```


```{r}
child_gen = function(p1, p2){
  #Finds the positions at which both parents have 1
  ph1 = which(p1 == 1, arr.ind = T) %>% as_tibble()
  ph2 = which(p2 == 1, arr.ind = T) %>% as_tibble()
  ind_11 = bind_rows(inner_join(ph1, ph2, by = c("row", "col")), 
                     inner_join(ph1, ph2, by = c("row", "col"))) %>% distinct()
  
  #calculates the avg genotypes for the parents 
  temp <- (p1 + p2) / 2
  
  # samples from 0,1 on positions where avg 0.5
  temp[temp == 0.5] <- sample(0:1,length(temp[temp == 0.5]), replace = TRUE)
  
  # samples from 1,2 on positions where avg 1.5
  temp[temp == 1.5] <- sample(1:2,length(temp[temp == 1.5]), replace = TRUE)
  
  # samples from 0,1,2 on positions where both parents have 1
  temp[as.matrix(ind_11)] <- sample(0:2, size = nrow(ind_11), replace = T)  
  return(temp)
}
```



```{r}
calc_gliab <- function(obj, beta, mu, sigma) {
  g_liab <- sweep(sweep(obj, 
                MARGIN = 2, 
                STATS = mu, 
                FUN = "-"), 
          MARGIN = 2, 
          STATS = sigma, 
          FUN = "/") %*% beta
  
  return(g_liab)
}
```


```{r}
calc_normalization_consts <- function(MAF, causal) {
  mu <- 2 * MAF * causal
  sigma <- sqrt((2 * MAF * causal)*(1 - MAF * causal))
  sigma[sigma == 0] <- 1
  
  return(list(mu = mu, sigma = sigma))
}

```



```{r}
sim_genotypes_no_family <- function(n, disease, path, overwrite = T, n_blocks = 20) {
  
  # Load disease information
  cols <- disease$N_SNP
  MAF <- disease$MAF
  beta <- disease$BETA
  causal <- disease$CAUSAL
  prevalence <- disease$PREVALENCE
  h2 <- disease$H2
  
  # Calculate normalization constants 
  norm_const <- calc_normalization_consts(MAF, causal)
  mu <- norm_const$mu
  sigma <- norm_const$sigma
  
  #Checks if a FBM with the given name and dimensions exists, else creates one
  FBM <- verifyRds(path, overwrite, n, cols)
  
  # Prepare for parallelization 
  plan(multisession, workers = max(1, availableCores(logical = F) - 1))
  
  # Prepare correct block indexes
  blocks <-  round(seq(0, n, length = n_blocks + 1))
  
  # Inserts values into FBM and calculate genetic liabilities in block sizes
  g_liabs <- future_lapply(1:(length(blocks) - 1), function(i) {  
    b_start <- blocks[i] + 1
    b_end <- blocks[i + 1]
    b_size <- (b_end - b_start + 1)
    
    FBM_temp <- matrix(rbinom(cols * b_size, 2, MAF),
                                    nrow = b_size,
                                    byrow = T)
  
    FBM$genotypes[b_start:b_end, ] <- FBM_temp

    g_block <- calc_gliab(FBM_temp, beta, mu, sigma)
    
  }, future.seed = T) %>% do.call("rbind", .) %>% as.numeric()
  
  # Saves liability and status information as well as SNP information in Rds
  threshold <- qnorm(prevalence, lower.tail = F)
  FBM$FAM$Genetic_Liability <- g_liabs
  FBM$FAM$Full_Liability <- g_liabs + rnorm(n, 0, sqrt(1 - h2))
  FBM$FAM$Status <- (FBM$FAM$Full_Liability > threshold) + 0

  FBM$MAP$MAF <- MAF
  FBM$MAP$BETA  <- beta
  
  return(FBM)
}

```




```{r}
sim_genotypes_with_family <- function(n, disease, path, n_sibs = NULL, overwrite = T, n_blocks = 20) {
  # Load disease information
  cols <- disease$N_SNP
  MAF <- disease$MAF
  beta <- disease$BETA
  causal <- disease$CAUSAL
  prevalence <- disease$PREVALENCE
  h2 <- disease$H2
  
  # Create or find FBM file to fill with child genotypes
  FBM <- verifyRds(path, overwrite, n, cols)

  # Create vector with number of sibs for each child
  if (!is.null(n_sibs)) {
    sibs_pr_child <- if (length(n_sibs) == 1) 
                        {rep(n_sibs,n)} else 
                          sample(min(n_sibs):max(n_sibs), n, replace = T)
  }

  # Initalize vectors for genetic liabilies
  p1_gliab <- numeric(n)
  p2_gliab <- numeric(n)
  child_gliab <- numeric(n)
  sibs_gliab <- vector(mode = "list", n)
  
  # Calculate normalization constants 
  norm_const <- calc_normalization_consts(MAF, causal)
  mu <- norm_const$mu
  sigma <- norm_const$sigma
  
  #prepare for block calculations 
  blocks <-  round(seq(0, n, length = n_blocks + 1))
  for (i in 1:(length(blocks)-1))  {  
    b_start <- blocks[i] + 1
    b_end <- blocks[i + 1]
    b_size <- (b_end - b_start + 1)

    # simulate parent 1 genotypes and genetic liabilities 
    p1 <- matrix(rbinom(cols * b_size, 2, MAF),
                 nrow = b_size,
                  byrow = T)
    p1_gliab[b_start:b_end] <- calc_gliab(p1, beta, mu, sigma)
      
    # simulate parent 2 genotypes and genetic liabilities 
    p2 <- matrix(rbinom(cols * b_size, 2, MAF),
                 nrow = b_size,
                  byrow = T)
    p2_gliab[b_start:b_end] <- calc_gliab(p2, beta, mu, sigma)
    
    # Simulate child genotypes and genetic liabilities - store genotypes in FBM
    child <- child_gen(p1, p2)
    FBM$genotypes[b_start:b_end, ] <- child
    child_gliab[b_start:b_end] <- calc_gliab(child, beta, mu, sigma)
    
    # Generate sibs for each child and calculate their genetic liabilities
    if (!is.null(n_sibs)) {
      for (s in 1:b_size) {
        sibs <- child_gen(matrix(rep(p1[s, ], sibs_pr_child[s]), sibs_pr_child[s], cols, byrow = T),
                          matrix(rep(p2[s, ], sibs_pr_child[s]), sibs_pr_child[s], cols, byrow = T))
        
        sibs_gliab[[b_start + s - 1]] <- calc_gliab(sibs, beta, mu, sigma)
      }
    }
  }
  
  # Calculate full liabilities/status and insert in rds file object
  threshold <- qnorm(prevalence, lower.tail = F)
  FBM$FAM$Genetic_Liability <- child_gliab
  FBM$FAM$Full_Liability <- child_gliab + rnorm(n, 0, sqrt(1 - h2))
  FBM$FAM$Status <- (FBM$FAM$Full_Liability > threshold) + 0
  FBM$FAM$p1_Status <- (p1_gliab + rnorm(n, 0, sqrt(1 - h2)) > threshold) + 0
  FBM$FAM$p2_Status <- (p2_gliab + rnorm(n, 0, sqrt(1 - h2)) > threshold) + 0
  
  FBM$MAP$MAF <- MAF
  FBM$MAP$BETA  <- beta
  
  if (!is.null(n_sibs)) {
    FBM$FAM$sibs_Genetic_Liability <- sibs_gliab
    FBM$FAM$sibs_Full_Liability <- purrr::map(sibs_gliab, .f = ~ 
                                       {if ( is.null(.x)) NULL 
                                        else .x + rnorm(length(.x), 0, sqrt(1 - h2))})
    FBM$FAM$sibs_Status <- purrr::map(FBM$FAM$sibs_Full_Liability, .f = ~ 
                                       {if ( is.null(.x)) NULL
                                        else(.x > threshold) + 0})
  }
  
  return(FBM)
  
  
}
```



```{r}
rnorm_trunc <- function(n, range, mu, sigma) {
  
  lower <- pnorm(min(range), mu, sigma)
  upper <- pnorm(max(range), mu, sigma)
  
  u <- runif(n, lower, upper)
  
  return(qnorm(u, mu, sigma))
}

```


```{r}
cond_calc <- function(i, covmatrix) {
  s11 <- covmatrix[i, i]
  s12 <- covmatrix[i, -i]
  s21 <- covmatrix[-i, i]
  s22 <- covmatrix[-i, -i]
  
  new_mu <- s12 %*% solve(s22) 
  new_sigma <- s11 - (s12 %*% solve(s22) %*% s21)
  return(list(mu = new_mu, sigma = new_sigma))
}

```


```{r}
covmatrix <- function(h2, n_sib = 0) {
  cov <- matrix(h2/2, 4 + n_sib, 4 + n_sib)
  diag(cov) <- 1
  cov[3,4] <- cov[4,3] <- 0
  cov[1:2, 1] <- cov[1, 1:2] <- h2
  
  return(cov)
}
```

```{r}
gibbs_sampler <- function(config, burn_in, cov_mat, prevalence) {
  l_n <- nrow(cov_mat) #number of l's
  threshold <- qnorm(prevalence, lower.tail = F) 
  
  gen_liabs <- numeric(burn_in + 10000)
  liabs_current <- rep(10,l_n) #initializing l's
  
  #pre-calculations for each l
  means <- matrix(ncol = l_n - 1, nrow = l_n)
  sigmas <- vector()
  for (p in 1:l_n) {
    temp <- cond_calc(p, cov_mat) 
    means[p, ] <- temp$mu
    sigmas[p] <- temp$sigma
  }
  
  SEM <- 1
  i <- 0
  
  # iterations
  while (SEM > 0.01) {
    i <- i + 1
    # iteration for each parameter
    for (p in 1:l_n) {
      new_mean <- means[p, ] %*% liabs_current[-p]
      
      #For genetic liability - no truncation 
      if (p == 1) {
        liabs_current[p] <- rnorm(1, new_mean, sqrt(sigmas[p]))
      }
      
      #For liabilties when we dont have case (0)
      else if (config[p-1] == 0) {
        liabs_current[p] <- rnorm_trunc(1, c(-Inf, threshold), new_mean, sqrt(sigmas[p]))
        
      }
      #For liability when we do have case (1)
      else {
        liabs_current[p] <- rnorm_trunc(1, c(threshold, Inf), new_mean, sqrt(sigmas[p]))
      }
    }
    gen_liabs[i] <- liabs_current[1]
    
    if (i > burn_in + 1000){
      SEM <- sd(gen_liabs[burn_in:i]) / sqrt(i - burn_in)
      
    }
  }
  return(mean(gen_liabs[burn_in:i]))
}
```


```{r}
GWAS <- function(person, y) {
  
  FBM <- person$genotypes
  
  #uses function from bigSNPr package to do regression on FBM
  regr <- big_univLinReg(FBM, y)
  #adds column with pvalues
  regr$p.value <- predict(regr, log10 = FALSE)
  
  return(data.frame(regr))
}

```


```{r}
GWAX <- function(child) {
  
  p1_Status <- child$FAM$p1_Status
  p2_Status <- child$FAM$p2_Status
  child_status <- child$FAM$Status
  FBM <- child$genotypes
  
  #Creates a vector of the proxy statuses for the child
  x <- (child_status == 1 | p1_Status == 1 | p2_Status == 1) + 0
  
  GWAS(child, x)
}

```


```{r}
LTFH <- function(child, prevalence, h2) {
  child_configs <- pmap(list(child$FAM$Status,child$FAM$p1_Status, child$FAM$p2_Status, child$FAM$sibs_Status), 
       function(x1, x2, x3, x4) 
                        paste(toString(x1),
                               toString(max(x2, x3)),
                               toString(min(x2, x3)),
                               strrep(1, sum(x4)),
                               strrep(0,length(x4) - sum(x4)),
                               sep = "")) %>% do.call("rbind", .)
  
  #Finds all the unique status configurations that the children have
  unique_configs <- unique(child_configs)
  
  #Calculates the the mean posterior genetic liability for each unique config
  config_liabs <- vector()
  for (config in unique_configs) {
    gibb_input <- as.numeric(strsplit(config,"")[[1]])
    config_liabs[config] <- gibbs_sampler(gibb_input, 100, covmatrix(h2 = h2, n_sib = length(gibb_input) - 3), prevalence)
  }
  
  n  <- nrow(child$genotypes)
  gen_liabs <- numeric(n)
  
  #Matches config of child to calculated mean posterior genetic liability
  for (i in 1:n) {
    gen_liabs[i] <- config_liabs[child_configs[i]]
  }

  return(GWAS(child, gen_liabs))
}

```


```{r}
Manhattan_plot <- function(x) {
  ggplot(x, aes(x=1:length(p.value), y=-log10(p.value), size=-log10(p.value))) + 
    geom_point(color="blue") + 
    ylim(0,15) +
    geom_hline(yintercept=-log10(5e-7), linetype=2) + xlab("SNP") + 
    ylab("-log10(P-value)")  
}
```


```{r}
causal <- numeric(5000)
causal[1:500] <- 1

dis <- simulate_disease(5000, 0.05, 0.8, causal = causal)
child <- sim_genotypes_with_family(5000, dis,"family_2_sibs",n_sibs = 2)

x <- GWAS(child, child$FAM$Status)
Manhattan_plot(x)
sum(x$p.value < 5e-7)

y <- GWAX(child)
Manhattan_plot(y)
sum(y$p.value < 5e-7)

z <- LTFH(child, prevalence = 0.05, h2 = 0.8)
Manhattan_plot(z)
sum(z$p.value < 5e-7)

```

