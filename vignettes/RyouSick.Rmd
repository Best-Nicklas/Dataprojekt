---
title: "Getting Started with RyouSick"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with RyouSick}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Simulation
To illustrate the use of RyouSick lets go through an example where we try to simulate a disease called bad-knee syndrome in a population.

When trying to simulate genotype and case-control phenotype data using RyouSick you first have to simulate the disease parameters. 
Disease parameters for our target disorder is simulated on 10 SNPs with a heritability h2 of 0.8 and a prevalence in the population of 0.25:

```{r, eval = FALSE}
library("RyouSick")
bad_knee_syndrome <- sim_disease(n_snp = 10, h2 = 0.8, prevalence = 0.5)
```
which outputs 
```{r}
bad_knee_syndrome
```

In the above output each MAF value at a given index indicates the frequency at which the genome will vary from the reference at the given position. The CAUSAL vector and BETA vector likewise tell us which SNPs are simulated to be causally connected to developing the simulated disease and how big of an effect they have. 

We can now chose what kind of simulation we want to perform for our population. Either with family information or without using the two functions:

* `sim_genotypes_no_family()` simulates genotype and case-control phenotype without family case-control phenotypes
* `sim_genotypes_with_family()` simulates genotype and case-control phenotype with family case-control phenotypes

Lets try to do a simulation of 10 genotypes under the bad_knee_syndrom disease parameters with 1 to 3 siblings for each genotype and save it under the filename "bad_knee_data10x10: 

```{r, warning = FALSE}
bad_knee_data <- sim_genotypes_with_family(n = 10, disease = bad_knee_syndrome, path = "bad_knee_data10x10",n_sibs = c(1,2,3))
```

The bad_knee_data will now contain a list object with reference to a file-backed matrix (matrix stored on disk), a tibble containing information on the disease (MAP) and a tibble containing phenotype information on the genotypes. Individual columns in the data can be accesed using the dollar notation

```{r}
bad_knee_data$FAM$Status
```
Slices of the genotype data can be accessed as well
```{r}
bad_knee_data$genotypes[1:10, 1:10]

```
(WARNING: we highly advise against indexing all the data at once using [], as this will try to load the whole file-backed matrix into memory, which depending on the size of the file might cause problems)

All of the simulated information contained in our example case bad_knee_data can be seen below

```{r}
knitr::kable(bad_knee_data$MAP, align = "ccc")
knitr::kable(bad_knee_data$FAM, align = "ccccccc")
```




## Analysis
We now perform analysis on our simulated data. The RyouSick package contains three methods for analysing the data: 

 * `GWAS()` Linear regression using genotype data and case-control status  
 * `GWAX()` Linear regression using genotype data and proxy case-control status  
 * `GWAX()` Linear regression using genotype data and posterior mean genetic liabilities
 
Lets now try each of the methods on our data:

```{r, warning=FALSE}
x <- GWAS(person = bad_knee_data, y = bad_knee_data$FAM$Status)
y <- GWAX(child = bad_knee_data)
z <- LTFH(child = bad_knee_data, h2 = 0.8, prevalence = 0.5)

```

Output will consist of estimated effect sizes, standard error, t-scores and pvalues for each SNP, which again can be accessed using dollar notation.

```{r}
knitr::kable(x)
```
Note that to access the analysis data for GWAX and LTFH you have to use `method_result$GWAS_Data$`.

## Visualizations

We can then visualize the data using the function `Manhattan_plot()` to get a picture of which SNPs have been determined to be causal: 

```{r}
#Manhattan_plot(x)
```




If we want to visually compare the accumulated power for each of the methods, we can use the function `Power_plots()`. First we need to save the GWAS_data for each method in a list format.

```{r}
#power_plot_data = list(x, y$GWAS_Data, z$GWAS_Data)
```

```{r}
#Power_plots(power_plot_data, 5e-3)

```


rds.obj


## Prediction

As seen in `vignette("LTFH")Â´ the best method for evalutating causal SNPs is LTFH. So 



## Correct formatting of rds object

If you wish to run the analysis methods on your own data it must first be formatted properly. To do so you must first initialize an empty .rds file and object matching the size of your data using the `createRds()` function.

```{r, eval=FALSE}
user_input_obj <- createRds("user_input_data", nrow = 10, ncol = 10)
user_input_obj
```

The rds object that is returned can then be filled up by adding columns in the MAP and FAM tibbles using dollar notation. To integrate with the methods in the package, columns must be given specific names based on their contents. The required information to run must functions and their naming is listed below

* MAF:  minor allele frequency for given SNP
* Status:  vector with status for genotypes
* p1_Status:  vector with parent 1 status for genotypes (only used in GWAX and LTFH)
* p2_Status:  vector with parent 2 status for genotypes (only used in GWAX and LTFH)
* sibs_Status:  list containing a vector with sibling status for each genotype or NULL if no siblings for genotype (only used in LTFH)

Note that the names are case-sensitive. 
addtionally, it is recommended that the file-backed matrix be filled in blocks if working with large quantities of data (read more in article `vignette(""Writing_efficient_R_code_and_working_with_large_datasets"")`). The rds file can later be opened again using the `openRds()` function.


## Paralization

Since most users work on very different computers with various setups paralization is not enabled by default. To run simulations using paralization, which is recommended as it provides a significant speedup, you must first set a paralaization plan. For most basic computers running on windows the paralization plan below will work just fine. 

```{r, eval = FALSE}
future::plan(future::multisession, workers = max(1, future::availableCores(logical = F) - 1))
```

The function should be called once before any simulations have been run.

We refer the reader to https://future.futureverse.org/reference/plan.html and the future backend to read up on on how to set up a plan that might work best on their machine. 



